[{"id":0,"href":"/csX114/docs/Course/01_computers_and_programming/","title":"01 Introduction into Computers and Programming","section":"Docs","content":" Introduction to Computers and Programming # What is a Computer? # Electronic device that proccess data by following a set of instructions (= program). It can perform calculations, store and retrieve information and controlls devices.\nVon Neumann Architecture # Proposed by John von Neumann in 1945.\nInput devices # Serve to enter data and instructions. Analogy: like your senses - they gather information for the computer from the outside worlds. Examples:\nKeyboard Mouse Microphone Scanner Touch display Output devices # Present results of computer’s processing to the user. Examples:\nMonitor Printers Speakers Analogy: your actions. You communicate with (towards) the world by them.\nHow does a CPU work? # Control Unit (CU): The Brain of the computer. Control Unit directs flow between memory, CPU, I/O devices Arithmetic Logic Unit (ALU): performs arithmetic (+, -, …) and logical operations (AND, OR). Logical operations are also called boolean operations after George Boole. True is often represented as 1 and False as 0.\nLogical AND # Input A Input B A ∧ B 0 0 0 0 1 0 1 0 0 1 1 1 Logical OR # Input A Input B A ∨ B 0 0 0 0 1 1 1 0 1 1 1 1 Memory and Storage # Registers # Registers are small, high-speed storage locations within the CPU itself. Extremely fast (much faster than memory or storage). Very limited in size (typically 8, 16, 32, or 64 bits wide, depending on the CPU architecture). Registers fetch instructions from memory, store intermediate computation results, and provide operands for the CPU. RAM # Memory is the part of the system used for temporarily storing data and instructions that the CPU needs during program execution. It acts as the workspace for active processes and provides data to the CPU. Stores instructions fetched from storage so that they can be quickly accessed. Slower than registers but faster than storage. Larger in size compared to registers (e.g., modern systems have several GBs of RAM). Volatile: contents are lost when power is turned off. The CPU reads instructions and data from memory into registers. Once a task is complete, results may be written back to memory. Storage # Storage refers to non-volatile devices, such as hard drives (HDDs), solid-state drives (SSDs), or even cloud storage (e.g. AWS S3). Long-term retention of data and programs, even when the computer is turned off. Much slower than both memory and registers. Much larger capacity compared to memory and registers (e.g., modern systems often have TBs of storage). Operating Systems # An Operating System (OS) is software that manages a computer’s hardware and software resources, acting as an intermediary between users and the computer hardware. It ensures efficient execution of programs, resource allocation, and system stability.\nFunctions # Process Management Memory Management File System Management Device Management User Interface Types # Windows UNIX Linux Android macOS iOS Programming Languages # Programming languages are the medium for humans to write programs that a computer can execute. They are needed to:\nBridge the gap: Computers understand only binary (0 and 1). Computer languages allow for writing instructions in a human readable form. Simplification : allow to break down problems into Resuse: programs can be reused and automate repetitive tasks. Types # Low-Level Languages # Machine Language: Example: 10110000 01100001 Assembly langauage: symbolic representation of machine language using mnemonics. Example: MOV A, 5 ADD B, A High-Level Languages # Designed to be easier to read and write, closer to human languages. Requires a compiler or interpreter (or both) to translate into machine code. Examples:\nC: very low-level and thus performant. Compiled. Non-portable. Java: First compiled. Then resulting code is interpreted in the Java Virtual Machine. Cross-platform. Popular for enterprise apps. JavaScript: Very high level. Leans closer to C-style syntax. Used in browsers to create Frontends. Python: Very high level, easy to read, beginner friendly. Cross-platform. Popular for data-science (AI), prototyping and scripting. High level scripting languages are used for automating tasks. Examples:\nPython Bash Compiled vs. Interpreted # Computer only understands machine code Some languages compile their files into machine code (e.g. C) Some take the source code and interpret it (e.g. Python) Some use both approaches (e.g. Java) Usually low-level (performant) languages are compiled and high-level (closer to human thinking) are interprete.\nCommon Characteristics # Syntax: rules, how code must be written. Semantics: Meaning of a statement or instruction. Example: print(\u0026#34;Hello\u0026#34;) 2+2 Control Structures: loops and condititionals that control the flow of exeuction. Example if, while. Categories of High-Level Languages # Procedural: focus on a sequence of steps to solve a problem. Example: C. Object-Oriented: model entities of outside worlds as objects encapsulating data and behavior. Example: Java, C++. Functional: focus on mathematical functions. Example: Haskell. Logical: express facts and rules for reasoning. Example: Prolog. Some programming languages fit into several categories, e.g. Python and Javascript support both procedural, object-oriented and functional programming.\nHomework (graded) # htop # Install htop. Don’t know how? Use Google/ChatGPT. Make a screenshot. Identify any process and explain what its values mean. "},{"id":1,"href":"/csX114/docs/Course/02_python_and_data/","title":"02 Python and Data","section":"Docs","content":" Python # Recap # Interactive Mode Scripts - files with .py extension Syntax and structure Syntax: rules, how code must be written. Semantics: Meaning of a statement or instruction. print() input() Variables # A variable is a name that stores a value, acting as a reference to that value in memory. It allows you to reuse and manipulate data in your programs. Example:\nx = 10 # Integer y = \u0026#34;Hello\u0026#34; # String z = 3.14 # Float x = \u0026#34;Now I\u0026#39;m a string!\u0026#34; # Reassignment Rules for Variable Names:\nMust start with a letter or an underscore (_). Cannot start with a number. Can contain letters, numbers, and underscores. Cannot use Python keywords (e.g., if, else, class). Snake Case # Snake case is a naming convention where words are written in lowercase and separated by underscores (_). It is commonly used in Python for variable and function names to improve readability. E.g. valid_name.\nComments # # this is the first comment spam = 1 # and this is the second comment # ... and now a third! text = \u0026#34;# This is not a comment because it\u0026#39;s inside quotes.\u0026#34; Statements and Expressions # Statement is a command. It does something, but not necessarily return a value. E.g. print Expression is a combination of values, variables, operators, function calls that evaluates to a value. E.g. 5, 2+2, pow(3, 2) + (3/4) You can execute several statements (expressions) in one line. Don\u0026rsquo;t do that! Stick to one idea/task/expression per line. That way it will be easier to understand.\nData # Data refers to information or values that a computer program processes, stores, or manipulates. It can be as simple as a single number or as complex as a collection of multimedia files. In programming, data is categorized into data types, which define the kind of value and what operations can be performed on it.\nKinds of data types:\nPrimitive: Basic, indivisible data types like integers, floats, and booleans. Structured: Organized collections of data, like arrays, lists, and objects. Hand in hand with data types go operators. An operator is a symbol or keyword in programming that performs an action or operation on data (called operands). For example, + is an operator that adds two numbers.\nNumeric # Integer: int Float: float Complex: complex \u0026gt;\u0026gt;\u0026gt; x = 42 \u0026gt;\u0026gt;\u0026gt; y = 3.14 \u0026gt;\u0026gt;\u0026gt; # Check types \u0026gt;\u0026gt;\u0026gt; type(x) \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; type(y) \u0026lt;class \u0026#39;float\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; # Perform basic arithmetic operations \u0026gt;\u0026gt;\u0026gt; x + y 45.14 \u0026gt;\u0026gt;\u0026gt; x - y 38.86 \u0026gt;\u0026gt;\u0026gt; x * y 131.88 \u0026gt;\u0026gt;\u0026gt; x / y # Division (always returns float) 13.375796178343949 \u0026gt;\u0026gt;\u0026gt; # Floor division and modulus (go hand in hand) \u0026gt;\u0026gt;\u0026gt; x // 5 # Integer division 8 \u0026gt;\u0026gt;\u0026gt; x % 5 # Remainder 2 \u0026gt;\u0026gt;\u0026gt; # Exponentiation \u0026gt;\u0026gt;\u0026gt; 2 ** 3 # 2 raised to the power of 3 8 \u0026gt;\u0026gt;\u0026gt; # Working with floats \u0026gt;\u0026gt;\u0026gt; z = 7.5 / 2 \u0026gt;\u0026gt;\u0026gt; z 3.75 \u0026gt;\u0026gt;\u0026gt; # Rounding floats \u0026gt;\u0026gt;\u0026gt; round(z, 1) # Round to 1 decimal place 3.8 \u0026gt;\u0026gt;\u0026gt; # Type conversions (casting) \u0026gt;\u0026gt;\u0026gt; int(z) # Convert float to integer (truncates) 3 \u0026gt;\u0026gt;\u0026gt; float(x) # Convert integer to float 42.0 \u0026gt;\u0026gt;\u0026gt; # Handling very large numbers \u0026gt;\u0026gt;\u0026gt; big_number = 12345678901234567890 \u0026gt;\u0026gt;\u0026gt; big_number * 2 24691357802469135780 \u0026gt;\u0026gt;\u0026gt; # Scientific notation for small numbers \u0026gt;\u0026gt;\u0026gt; small_number = 1e-10 # Equivalent to 0.0000000001 \u0026gt;\u0026gt;\u0026gt; small_number 1e-10 \u0026gt;\u0026gt;\u0026gt; # Some built-in functions \u0026gt;\u0026gt;\u0026gt; abs(-42) # Absolute value 42 \u0026gt;\u0026gt;\u0026gt; pow(2, 3) # 2 raised to the power of 3 (same as 2 ** 3) 8 For some float numbers computers cannot represent them exactly. Therefore, never compare floats (but use greater-than or lesser-than):\na = 0.1 + 0.2 b = 0.3 # Direct comparison if a == b: print(\u0026#34;a and b are equal\u0026#34;) else: print(\u0026#34;a and b are NOT equal\u0026#34;) print(f\u0026#34;a: {a}, b: {b}\u0026#34;) Text # String: str Existing strings cannot be changed. You can only use them to create new strings out of the existing ones. \u0026gt;\u0026gt;\u0026gt; # Let\u0026#39;s start with basic strings \u0026gt;\u0026gt;\u0026gt; name = \u0026#34;Alice\u0026#34; \u0026gt;\u0026gt;\u0026gt; greeting = \u0026#34;Hello\u0026#34; \u0026gt;\u0026gt;\u0026gt; # Check the type of a string \u0026gt;\u0026gt;\u0026gt; type(name) \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; # Concatenate strings \u0026gt;\u0026gt;\u0026gt; full_greeting = greeting + \u0026#34;, \u0026#34; + name + \u0026#34;!\u0026#34; \u0026gt;\u0026gt;\u0026gt; full_greeting \u0026#39;Hello, Alice!\u0026#39; \u0026gt;\u0026gt;\u0026gt; # Repeating strings \u0026gt;\u0026gt;\u0026gt; excited_greeting = full_greeting * 2 \u0026gt;\u0026gt;\u0026gt; excited_greeting \u0026#39;Hello, Alice!Hello, Alice!\u0026#39; \u0026gt;\u0026gt;\u0026gt; # Accessing characters by index \u0026gt;\u0026gt;\u0026gt; full_greeting[0] # First character \u0026#39;H\u0026#39; \u0026gt;\u0026gt;\u0026gt; full_greeting[-1] # Last character \u0026#39;!\u0026#39; \u0026gt;\u0026gt;\u0026gt; # Slicing strings \u0026gt;\u0026gt;\u0026gt; full_greeting[0:5] # First 5 characters \u0026#39;Hello\u0026#39; \u0026gt;\u0026gt;\u0026gt; full_greeting[7:] # Everything from index 7 onwards \u0026#39;Alice!\u0026#39; \u0026gt;\u0026gt;\u0026gt; full_greeting[:5] # Everything up to index 5 (exclusive) \u0026#39;Hello\u0026#39; \u0026gt;\u0026gt;\u0026gt; # String length \u0026gt;\u0026gt;\u0026gt; len(full_greeting) 13 \u0026gt;\u0026gt;\u0026gt; # Converting case \u0026gt;\u0026gt;\u0026gt; full_greeting.upper() # Uppercase \u0026#39;HELLO, ALICE!\u0026#39; \u0026gt;\u0026gt;\u0026gt; full_greeting.lower() # Lowercase \u0026#39;hello, alice!\u0026#39; \u0026gt;\u0026gt;\u0026gt; # The function as `object.function` is called a `method`. More on methods in the OOP class. \u0026gt;\u0026gt;\u0026gt; # Stripping whitespace \u0026gt;\u0026gt;\u0026gt; padded = \u0026#34; hello, world! \u0026#34; \u0026gt;\u0026gt;\u0026gt; padded.strip() \u0026#39;hello, world!\u0026#39; \u0026gt;\u0026gt;\u0026gt; padded.lstrip() \u0026#39;hello, world! \u0026#39; \u0026gt;\u0026gt;\u0026gt; padded.rstrip() \u0026#39; hello, world!\u0026#39; \u0026gt;\u0026gt;\u0026gt; # Splitting strings \u0026gt;\u0026gt;\u0026gt; sentence = \u0026#34;Python is awesome\u0026#34; \u0026gt;\u0026gt;\u0026gt; words = sentence.split() # Split into a list of words (we\u0026#39;ll deal with lists later) \u0026gt;\u0026gt;\u0026gt; words [\u0026#39;Python\u0026#39;, \u0026#39;is\u0026#39;, \u0026#39;awesome\u0026#39;] \u0026gt;\u0026gt;\u0026gt; # Joining strings \u0026gt;\u0026gt;\u0026gt; \u0026#34;-\u0026#34;.join(words) # Combine words with a hyphen \u0026#39;Python-is-awesome\u0026#39; \u0026gt;\u0026gt;\u0026gt; # Checking substrings \u0026gt;\u0026gt;\u0026gt; \u0026#34;awesome\u0026#34; in sentence # Is \u0026#34;awesome\u0026#34; part of the sentence? True \u0026gt;\u0026gt;\u0026gt; \u0026#34;boring\u0026#34; in sentence False \u0026gt;\u0026gt;\u0026gt; # Replacing parts of a string \u0026gt;\u0026gt;\u0026gt; # does not change existing string but creates a new string! \u0026gt;\u0026gt;\u0026gt; sentence.replace(\u0026#34;awesome\u0026#34;, \u0026#34;fantastic\u0026#34;) \u0026#39;Python is fantastic\u0026#39; \u0026gt;\u0026gt;\u0026gt; # Formatting strings - string interpolatoin \u0026gt;\u0026gt;\u0026gt; age = 25 \u0026gt;\u0026gt;\u0026gt; formatted = f\u0026#34;My name is {name} and I am {age} years old.\u0026#34; \u0026gt;\u0026gt;\u0026gt; formatted \u0026#39;My name is Alice and I am 25 years old.\u0026#39; \u0026gt;\u0026gt;\u0026gt; # Advanced formatting (see: https://pyformat.info/) \u0026gt;\u0026gt;\u0026gt; pi = 3.14159 \u0026gt;\u0026gt;\u0026gt; f\u0026#34;The value of pi is approximately {pi:.2f}\u0026#34; # Format to 2 decimal places \u0026#39;The value of pi is approximately 3.14\u0026#39; Strings are texts in quotes (\u0026quot;) or apostrophes (') on one line. Multiline strings begin and end with triple quotes or apostrophes. E.g.: \u0026gt;\u0026gt;\u0026gt; long_text = \u0026#34;\u0026#34;\u0026#34;Line 1 ... Line 2 ... ... ... and here is the END\u0026#34;\u0026#34;\u0026#34; \u0026gt;\u0026gt;\u0026gt; long_text \u0026#39;Line 1\\nLine 2\\n...\\nand here is the END\u0026#39; \u0026gt;\u0026gt;\u0026gt; \\n is new line character. All characters starting with \\ are called escape sequences and contain special characters. input() always returns a string, even if the user enter digits. It\u0026rsquo;s your job to convert it to number. Example:\n\u0026gt;\u0026gt;\u0026gt; number = input(\u0026#34;Please enter a number: \u0026#34;) Please enter a number: 42 \u0026gt;\u0026gt;\u0026gt; number \u0026#39;42\u0026#39; \u0026gt;\u0026gt;\u0026gt; type(number) \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; number = int(number) \u0026gt;\u0026gt;\u0026gt; type(number) \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; number 42 Homework (graded) # Calculator # Create a program that will read three numbers, store them in three distinct variables and then create the sum of them. This will be stored in another variable. Then it will print the variable result saying: \u0026ldquo;result is N\u0026rdquo; where N is the sum.\nMeter # Create a program that will let the user input his name. The program will then say how many characters are there in his name.\nExtra points: if spaces are inserted, substract their count from the result, so that \u0026ldquo;Peter Pan\u0026rdquo; will return 8 and not 9.\n"},{"id":2,"href":"/csX114/docs/Course/03_control_structures_and_loops/","title":"03 Control Strutures and Loops","section":"Docs","content":" Conditionals # Conditionals in a programming language are used to make decisions in the flow of a program based on whether certain conditions are met. They allow the program to execute different code paths depending on the evaluation of a condition (True or False).\nbool Data Type # Valid values are True and False. Comparisons yield these values. Used in condition and logical operations.\n\u0026gt;\u0026gt;\u0026gt; # Booleans represent True or False \u0026gt;\u0026gt;\u0026gt; t = True \u0026gt;\u0026gt;\u0026gt; f = False \u0026gt;\u0026gt;\u0026gt; # Check the type of a boolean \u0026gt;\u0026gt;\u0026gt; type(t) \u0026lt;class \u0026#39;bool\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; # Boolean operations \u0026gt;\u0026gt;\u0026gt; t and f # Logical AND (yields True if both operands are True) False \u0026gt;\u0026gt;\u0026gt; t or f # Logical OR (yields True if any of the operands is True) True \u0026gt;\u0026gt;\u0026gt; not t # Logical NOT False \u0026gt;\u0026gt;\u0026gt; # Booleans with comparison operators \u0026gt;\u0026gt;\u0026gt; 5 \u0026gt; 3 True \u0026gt;\u0026gt;\u0026gt; 5 \u0026lt; 3 False \u0026gt;\u0026gt;\u0026gt; 5 == 5 True \u0026gt;\u0026gt;\u0026gt; 5 != 3 True \u0026gt;\u0026gt;\u0026gt; # Combining comparisons \u0026gt;\u0026gt;\u0026gt; 5 \u0026gt; 3 and 2 \u0026lt; 4 True \u0026gt;\u0026gt;\u0026gt; 5 \u0026gt; 3 or 2 \u0026gt; 4 True \u0026gt;\u0026gt;\u0026gt; not (5 \u0026gt; 3) False \u0026gt;\u0026gt;\u0026gt; # Booleans with arithmetic operations \u0026gt;\u0026gt;\u0026gt; True + 1 # True is treated as 1 2 \u0026gt;\u0026gt;\u0026gt; False + 1 # False is treated as 0 1 \u0026gt;\u0026gt;\u0026gt; # Boolean casting \u0026gt;\u0026gt;\u0026gt; bool(1) # Non-zero numbers are True True \u0026gt;\u0026gt;\u0026gt; bool(0) # Zero is False False \u0026gt;\u0026gt;\u0026gt; bool(\u0026#34;Hello\u0026#34;) # Non-empty strings are True True \u0026gt;\u0026gt;\u0026gt; bool(\u0026#34;\u0026#34;) # Empty strings are False False \u0026gt;\u0026gt;\u0026gt; bool([]) # Empty lists are False False \u0026gt;\u0026gt;\u0026gt; bool([1, 2, 3]) # Non-empty lists are True True \u0026gt;\u0026gt;\u0026gt; age = 19 \u0026gt;\u0026gt;\u0026gt; is_adult = age \u0026gt;= 18 # expression + assignment \u0026gt;\u0026gt;\u0026gt; is_adult True None Data Type # None is a special constant in Python that represents the absence of a value or a null value.\n\u0026gt;\u0026gt;\u0026gt; x = None \u0026gt;\u0026gt;\u0026gt; x is None True \u0026gt;\u0026gt;\u0026gt; x is not None False \u0026gt;\u0026gt;\u0026gt; if Statement # The if statement allows executing a block of code if a condition is True.\nx = 10 if x \u0026gt; 5: print(\u0026#34;x is greater than 5\u0026#34;) # Output: x is greater than 5 Nested Conditions # x = 10 if x \u0026gt; 5: if x \u0026lt; 15: print(\u0026#34;x is between 5 and 15\u0026#34;) # Output: x is between 5 and 15 Logical Operations in Conditions # Combine conditions using and, or, and not.\nx = 10 if x \u0026gt; 5 and x \u0026lt; 15: print(\u0026#34;x is between 5 and 15\u0026#34;) # Output: x is between 5 and 15 if-else Statement # Adds an alternative block when the condition is False.\nx = 3 if x \u0026gt; 5: print(\u0026#34;x is greater than 5\u0026#34;) else: print(\u0026#34;x is not greater than 5\u0026#34;) # Output: x is not greater than 5 if-elif-else Statement # x = 7 if x \u0026gt; 10: print(\u0026#34;x is greater than 10\u0026#34;) elif x \u0026gt; 5: print(\u0026#34;x is greater than 5 but not more than 10\u0026#34;) # Output else: print(\u0026#34;x is 5 or less\u0026#34;) There can be any number of elif sections.\nLoops # Loops execute a block of code repeatedly, saving time and effort. They\u0026rsquo;re used for:\nRepetition: Automate repetitive tasks. Example: Printing numbers 1 to 10. Iteration: Process items in a sequence (e.g., list or string). Example: Summing numbers in a list. Conditional Repetition. Example: Prompt user until input is valid. while loop # Repeats as long as the condition is True.\nx = 1 while x \u0026lt;= 5: print(x) # Output: 1 2 3 4 5 x += 1 break and continue # break exits the loop. continue skips to the next iteration. x = 0 while x \u0026lt; 5: x += 1 if x == 3: continue if x == 5: break print(x) # Output: 1 2 4 Both keywords work in both while and for loops.\nfor loop # Iterates over a sequence.\nfor i in [1, 2, 3]: print(i) # Output: 1 2 3 range() function # Generates a sequence of numbers.\nfor i in range(1, 6): print(i) # Output: 1 2 3 4 5 nested loops # Loops inside loops for multi-dimensional iteration.\nfor i in range(1, 3): for j in range(1, 3): print(f\u0026#34;i={i}, j={j}\u0026#34;) infinite loops # while True: print(\u0026#34;Infinite Loop\u0026#34;) Break out of the loop by pressing CTRL-C.\npass # A placeholder that does nothing but satisfies syntax requirements.\nfor i in range(3): pass # Placeholder for future code Homework (graded) # conditionals # Create a calculator that will ask the user for operand1, operation (+/-/*/division), operand2 and will read the values, convert them to numbers and print the result\nloops # Create a Number Guessing Game in Python. Write a Python program that allows a user to guess a secret number between 1 and 10. The program should guide the user by providing feedback on whether their guess is too low, too high, or correct. The game continues until the user guesses the correct number.\n"},{"id":3,"href":"/csX114/docs/Course/04_algorithm/","title":"04 Algorithms","section":"Docs","content":" What Is an Algorithm? # An algorithm is a step-by-step set of instructions designed to perform a specific task or solve a particular problem. It is the foundation of all computer programs and is used to process data, make decisions, or automate repetitive tasks.\nDaily Life Examples of Algorithm # Making a Cup of Tea:\nStep 1: Fill the kettle with water. Step 2: Boil the water. Step 3: Place a tea bag in a cup. Step 4: Pour boiling water into the cup. Step 5: Add sugar/milk if desired. Step 6: Stir and serve. Finding a Word in a Dictionary:\nStep 1: Open the dictionary. Step 2: Locate the section based on the first letter of the word. Step 3: Narrow down based on the second and subsequent letters. Step 4: Find the word and read its definition. Crossing the Street:\nStep 1: Look left. Step 2: Look right. Step 3: Look left again. Step 4: If the road is clear, cross; otherwise, wait. Key Features of an Algorithm: # Input: The algorithm accepts zero or more inputs to work with. Output: The algorithm produces one (or multiple) result or outcome (procedures produce no result). Definiteness: Each step must be clearly defined without ambiguity. Finiteness: The algorithm must terminate after a finite number of steps. Effectiveness: Each step of the algorithm can be performed in a finite amount of time using available resources. KISS (Keep It Simple Stupid)\nWhat Is Pseudocode? # Pseudocode is a simplified, informal way of writing algorithms that uses plain language and basic programming constructs without worrying about syntax. It bridges the gap between human thinking and actual code. Example of Pseudocode:\nTask: Find the largest number in a list. Input: list of numbers 1. Initialize a variable Max to the first element of the list. 2. For each element in the list: a. If the element is greater than Max: i. Set Max to this element. 3. Output: Max. Advantages of Using Pseudocode # Language-Independent: It\u0026rsquo;s not tied to a specific programming language. Focus on Logic: Allows the designer to focus on the algorithm\u0026rsquo;s structure without worrying about syntax. Easy to Understand: Non-programmers can follow and provide feedback. MSI # Manually. Always solve the problem manually first (ideally on paper). Step-by-Step. Then design the algorithm. What are the steps that need to be taken? Impelement. Proceed to implement the algorithm in a programming language. Homework (graded) # Given a string. Return two numbers (tuple), the first will represent the number of spaces in the string, the other of non-spaces. Your task is pass the M. and S. steps on paper and only then to implement the algorithm in Python. Both the paper and the script are required.\nUse for loop to iterate over the string, you\u0026rsquo;re not allowed to use len function and string.count method.\n"},{"id":4,"href":"/csX114/docs/Course/05_functions/","title":"05 Functions","section":"Docs","content":" Funtions in Python # Introduction # Functions are reusable blocks of code that perform a specific task. They implement na algorithm. Moreover, they help us organize and structure our programs, avoid repetition, and improve readability.\nFunction reduce complexity, as the user (caller) of a function doesn\u0026rsquo;t need to know the algorithm, only what\u0026rsquo;s the input and expected output. Thus, from the perspective of the caller of the function it is a blackbox.\nFunctions are one of the most importants concepts in programming.\nA function in Python is defined using the def keyword:\n# Defining function def greet(): print(\u0026#34;Hello, World!\u0026#34;) # Calling the function greet() A function like greet that doesn\u0026rsquo;t contain a return statement automatically returns the value None. As such it is also called a procedure. A proper function returns a value. Example:\ndef calculate_circumference(radius): if radius \u0026lt; 0: raise ValueError(\u0026#34;Radius cannot be negative\u0026#34;) pi = 3.141592653589793 return 2 * pi * radius radius = 5 circumference = calculate_circumference(radius) print(f\u0026#34;The circumference of a circle with radius {radius} is {circumference}\u0026#34;) When a return statement is executed, the function terminates at that point returning the value to the caller and gives control to the caller.\nArguments # Functions can accept inputs called arguments. These allow the function to work with dynamic data.\nPositional Arguments # Positional arguments are the most common type. Their order is important:\ndef greet_person(name): # `name` is a positional argument print(f\u0026#34;Hello, {name}!\u0026#34;) greet_person(\u0026#34;Alice\u0026#34;) The values passed to a function in the place of an argument are called parameters. So in the example above the parameter for greet_person is \u0026quot;Alice\u0026quot;.\nDefault Arguments # Default arguments have predefined values. If not provided during the call, the default is used:\ndef greet_person(name=\u0026#34;Stranger\u0026#34;): print(f\u0026#34;Hello, {name}!\u0026#34;) # Calling the function greet_person() # Uses default value greet_person(\u0026#34;Bob\u0026#34;) # Overrides default value Arbitrary Argument List # Sometimes, you may not know how many arguments will be passed to the function. You can use *args to accept a variable number of arguments:\ndef greet_people(*names): for name in names: print(f\u0026#34;Hello, {name}!\u0026#34;) greet_people(\u0026#34;Alice\u0026#34;, \u0026#34;Bob\u0026#34;, \u0026#34;Charlie\u0026#34;) Arbitrary Keyword Arguments # def describe_person(**details): for key, value in details.items(): print(f\u0026#34;{key}: {value}\u0026#34;) # Calling the function describe_person(name=\u0026#34;Alice\u0026#34;, age=25, location=\u0026#34;New York\u0026#34;) Docstrings # A docstring is a special string that describes what the function does. It is written as the first statement inside the function body and is usually enclosed in triple quotes (\u0026quot;\u0026quot;\u0026quot; or \u0026lsquo;\u0026rsquo;\u0026rsquo;).\n# Example: Function with Docstring def greet_person(name): \u0026#34;\u0026#34;\u0026#34; Greets a person with the provided name. Args: name (str): The name of the person to greet. Returns: None \u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;Hello, {name}!\u0026#34;) print(greet_person.__doc__) # Accessing a function\u0026#39;s docstring greet_person(\u0026#39;Peter\u0026#39;) # Calling is as usual Homework (graded) # Basic Function # Write a function say_hello that prints \u0026ldquo;Hello, Python!\u0026rdquo;. Call the function to ensure it works.\nPositional and Default Arguments # Write a function introduce that takes two arguments: name and age (default value for age should be 18). Print a sentence introducing the person. Call the function with both arguments and with only name.\nArbitrary Arguments # Write a function list_hobbies that accepts any number of hobby names using *args. Print all hobbies passed to the function. Call the function with at least three hobby names.\nKeyword Arguments # Write a function person_details that accepts name, age, and city as keyword arguments. Print these details in a formatted string. Call the function using keyword arguments in different orders.\nArbitrary Keyword Arguments # Write a function profile that accepts any number of keyword arguments using **kwargs. Print all the key-value pairs in a readable format. Call the function with at least three key-value pairs.\nDocstring # Write a function calculate_area that calculates and returns the area of a rectangle given length and width. Add a docstring explaining the purpose of the function, its arguments, and what it returns. Access and print the docstring. Call the function to test it.\nCombo # Combine all these concepts into a single function full_profile that takes:\nA mandatory positional argument for name. A default argument for age. An arbitrary list of hobbies using *args. Additional details using **kwargs. Print the complete profile in a structured format.\n"},{"id":5,"href":"/csX114/docs/Course/06_structures/","title":"06 Structures","section":"Docs","content":" Structures # Structures in programming are ways to organize, store, and manage data efficiently. They determine how data is arranged in memory and how operations like accessing, adding, or modifying data can be performed.\nStructures in Python are called collections and create complex data types out of primitive ones or other structures.\nTuple # Immutable, ordered collections of items.\nCannot be changed after creation. Just like strings. Use parentheses () to define. # Example: Storing coordinates point = (3, 5) print(\u0026#34;X:\u0026#34;, point[0], \u0026#34;Y:\u0026#34;, point[1]) # Tuple unpacking x, y = point print(f\u0026#34;Point coordinates: X={x}, Y={y}\u0026#34;) The parentheses can be omitted. Python will know based on the coma that it deals with a tuple:\npoint = 3, 5 print(\u0026#34;X:\u0026#34;, point[0], \u0026#34;Y:\u0026#34;, point[1]) Lists # Mutable, ordered collections of items.\nCan grow or shrink dynamically. Use square brackets [] to define. # Example: Managing a to-do list tasks = [\u0026#34;Read book\u0026#34;, \u0026#34;Write code\u0026#34;, \u0026#34;Go jogging\u0026#34;] tasks.append(\u0026#34;Cook dinner\u0026#34;) # Add an item tasks.remove(\u0026#34;Write code\u0026#34;) # Remove an item print(tasks) # Access by index print(\u0026#34;First task:\u0026#34;, tasks[0]) Sets # Unordered collections of unique items.\nDoesn\u0026rsquo;t allow for duplicates. Use curly braces {} to define or set() constructor. # Example: Removing duplicates from a list numbers = [1, 2, 3, 1, 2, 4] unique_numbers = set(numbers) print(\u0026#34;Unique numbers:\u0026#34;, unique_numbers) # Set operations set_a = {1, 2, 3} set_b = {3, 4, 5} print(\u0026#34;Union:\u0026#34;, set_a | set_b) # Combine both sets print(\u0026#34;Intersection:\u0026#34;, set_a \u0026amp; set_b) # Common elements Dictionaries # Mutable, unordered collections of key-value pairs.\nKeys are unique and immutable. Use curly braces {} with key-value pairs to define. # Example: Storing user information user = { \u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 25, \u0026#34;location\u0026#34;: \u0026#34;New York\u0026#34; } print(user[\u0026#34;name\u0026#34;]) # Access value by key # Adding or modifying key-value pairs user[\u0026#34;age\u0026#34;] = 26 user[\u0026#34;email\u0026#34;] = \u0026#34;alice@example.com\u0026#34; print(user) # Iterating over keys and values for key, value in user.items(): print(f\u0026#34;{key}: {value}\u0026#34;) Summary # Structure Mutable Ordered Unique Items Common Use Tuple No Yes No Fixed data List Yes Yes No Dynamic data Set Yes No Yes Unique items Dict Yes No Keys are unique Key-value pairs Homework (graded) # Books # Create a list of your favorite books. Remove duplicates using a set.\nCities # Store details about a city (name, population, country) in a dictionary and update the population.\nDistance in 3D space # Use a tuple to represent a point in a 3D space and calculate its distance from the origin.\n"},{"id":6,"href":"/csX114/docs/Course/07_io/","title":"07 Input/Output","section":"Docs","content":" Input/Output # Communication with the user and the environment.\nString Interpolation # String interpolation is inserting variables or expressions into strings. Python offers several ways to achieve this:\nf-strings (from Python 3.6): f\u0026quot;Hello, {name}\u0026quot;. str.format(): \u0026ldquo;Hello, {}\u0026quot;.format(name). % strings: \u0026ldquo;Hello, %s\u0026rdquo; % name We focus here only on the first method. Examples:\nname = \u0026#34;Alice\u0026#34; age = 25 # Using f-strings greeting = f\u0026#34;Hello, {name}! You are {age} years old.\u0026#34; print(greeting) # Evaluating expressions in f-strings calculation = f\u0026#34;2 + 2 = {2 + 2}\u0026#34; print(calculation) String Formatting # Formatting strings allows control over how data appears. Use placeholders for alignment, padding, or precision:\n{}: Default placeholder. {:.2f}: Floating-point with 2 decimal places. {:\u0026lt;10}: Left-align in 10-character width. Example:\n# Numeric formatting price = 19.99 formatted_price = f\u0026#34;Price: ${price:.2f}\u0026#34; # Two decimal places print(formatted_price) # Alignment data = \u0026#34;Python\u0026#34; print(f\u0026#34;\u0026#39;{data:\u0026lt;10}\u0026#39;\u0026#34;) # Left-align print(f\u0026#34;\u0026#39;{data:\u0026gt;10}\u0026#39;\u0026#34;) # Right-align print(f\u0026#34;\u0026#39;{data:^10}\u0026#39;\u0026#34;) # Center-align Fore more information check out the tutorial or visit pyformat.info for more in-depth description.\nConsole # You can interact with the user via the console (in text based UIs):\n# Printing output print(\u0026#34;Welcome to the console class!\u0026#34;) # Getting user input name = input(\u0026#34;Enter your name: \u0026#34;) print(f\u0026#34;Hello, {name}!\u0026#34;) Advanced stuff:\n# Print without a newline print(\u0026#34;Loading\u0026#34;, end=\u0026#34;\u0026#34;) for _ in range(3): print(\u0026#34;.\u0026#34;, end=\u0026#34;\u0026#34;) print(\u0026#34; Done!\u0026#34;) # Formatting console output value = 42 print(f\u0026#34;The answer is: {value:010}\u0026#34;) # Padded with zeroes Files # Files allow reading and writing persistent data (on storage). Python uses the open() function with modes:\n'r': Read. 'w': Write (overwrites existing content). 'a': Append. Boy scout rule - always leave the place in the same or better state as you encountered it. Thus always close the files after you finished working with them. If you use the with keyword to work with them, Python will do that for you automatically, even if an exception occurs while working with it.\nExamples:\n# Writing to a file with open(\u0026#34;example.txt\u0026#34;, \u0026#34;w\u0026#34;) as file: file.write(\u0026#34;Hello, file!\u0026#34;) # Reading from a file with open(\u0026#34;example.txt\u0026#34;, \u0026#34;r\u0026#34;) as file: content = file.read() print(\u0026#34;File content:\u0026#34;, content) # Appending to a file with open(\u0026#34;example.txt\u0026#34;, \u0026#34;a\u0026#34;) as filehttps://docs.python.org/3/tutorial/inputoutput.html: file.write(\u0026#34;\\nThis is appended text.\u0026#34;) # Reading line by line with open(\u0026#34;example.txt\u0026#34;, \u0026#34;r\u0026#34;) as file: for line in file: print(line.strip()) Command Line Arguments (sys.argv) # The sys.argv list allows you to access command-line arguments passed to a Python script.\nsys.argv[0] is the name of the script, and subsequent elements are the arguments.\nExample:\nimport sys # Example: Accessing command-line arguments if len(sys.argv) \u0026gt; 1: print(\u0026#34;Arguments passed:\u0026#34;, sys.argv[1:]) else: print(\u0026#34;No arguments passed.\u0026#34;) # Example: Simple command-line calculator if len(sys.argv) == 4: num1 = float(sys.argv[1]) operator = sys.argv[2] num2 = float(sys.argv[3]) if operator == \u0026#39;+\u0026#39;: print(f\u0026#34;Result: {num1 + num2}\u0026#34;) elif operator == \u0026#39;-\u0026#39;: print(f\u0026#34;Result: {num1 - num2}\u0026#34;) elif operator == \u0026#39;*\u0026#39;: print(f\u0026#34;Result: {num1 * num2}\u0026#34;) elif operator == \u0026#39;/\u0026#39;: print(f\u0026#34;Result: {num1 / num2}\u0026#34;) else: print(\u0026#34;Unsupported operator!\u0026#34;) else: print(\u0026#34;Usage: python script.py \u0026lt;num1\u0026gt; \u0026lt;operator\u0026gt; \u0026lt;num2\u0026gt;\u0026#34;) Homework (graded) # Formatting # Create a formatted report with the names and scores of students using string formatting. The numbers following the names should be aligned. Sort it by grade, best being on top. Here is the input data:\nresults = { \u0026#39;Joe\u0026#39;: 75, \u0026#39;Freddy\u0026#39;: 81, \u0026#39;Peter\u0026#39;: 55, \u0026#39;DeAnna\u0026#39;: 75, } FileIO # Write a script to:\nAsk the user for their name and age. Save this data to a file. Read and display the content of the file. "},{"id":7,"href":"/csX114/docs/Course/08_errors_and_exceptions/","title":"08 Errors and Exceptions","section":"Docs","content":" Errors and Exceptions # Errors: Issues in the syntax or runtime of a program that cause it to stop. Exceptions: Errors detected during execution. Handling errors/exceptoins is essential!\nTypes of Errors # Below you\u0026rsquo;ll find some types of errors. Please spot and fix them.\nSyntax Errors # print(\u0026#34;Hello World\u0026#34; Runtime Errors # x = 10 / 0 Difficult to handle beforehand.\nLogical Errors # Also called bugs. Here is a program to sum up to numbers 1 to 5 inclusively.\ntotal = 0 for i in range(1, 5): total += i print(total) The program prints 10 even though I\u0026rsquo;m expecting 15!\nExceptions and Handling them # try-except block # try: num = int(input(\u0026#34;Enter a number: \u0026#34;)) print(10 / num) except ZeroDivisionError: print(\u0026#34;You cannot divide by zero.\u0026#34;) except ValueError: print(\u0026#34;Please enter a valid number.\u0026#34;) using else and finally # try: file = open(\u0026#34;example.txt\u0026#34;, \u0026#34;r\u0026#34;) content = file.read() print(content) except FileNotFoundError: print(\u0026#34;File not found.\u0026#34;) finally: print(\u0026#34;Execution complete.\u0026#34;) Activity: write code that safely handles user input for dividing two numbers (5 min)\nDebugging basics # Print statements IDE tools Common errors to look for: indentation, incorrect data types, off-by-one errors. def sum_list(numbers): result = 0 for num in numbers: result += num return result print(sum_list([1, 2, 3, \u0026#34;4\u0026#34;])) # Debug this! Clean Code Basics # Some basic rules:\nUse meaningful variable names. Magic Constants -\u0026gt; extract then into named constants at the top of the file Copy \u0026amp; Paste -\u0026gt; DRY (Don\u0026rsquo;t Repeat Yourself), and/or use functions Formatting Dead Code Useless Comments No Main Function Homework (graded) # Exception Handling # Write a program:\nPrompt the user for a file name. Try to open the file and print its contents. Handle exceptions for: File not found. Permission error. Any other error. Handle this error by telling the user also what kind of error has happened. Refactoring # Refactor the following code:\nimport random a = [] a.append(int(random.random() * 100)) a.append(int(random.random() * 100)) a.append(int(random.random() * 100)) a.append(int(random.random() * 100)) a.append(int(random.random() * 100)) a.append(int(random.random() * 100)) a.append(int(random.random() * 100)) a.append(int(random.random() * 100)) a.append(int(random.random() * 100)) a.append(int(random.random() * 100)) c = 0 # last = None # for new in a: # if last == new: # a.remove(new) # last = new for i in range(0,10): # here we loop if (a[i]%7== 0): c += 1 if (a[i]%11==0): c += 1 if (a[i] % 7 == 0): print(a[i], \u0026#34;is divisible by 7 or 11\u0026#34;) if (a[i] % 11 == 0): print(a[i], \u0026#34;is divisible by 7 or 11\u0026#34;) print(\u0026#34;found\u0026#34;, c, \u0026#34;numbers divisible by 7 or 11\u0026#34;) Make sure to:\nUse proper variable names Use named constants instead of magical ones Remove copy\u0026amp;paste code Factor a function where possible/useful/required Join logical conditions in Control Structures if they have the same branch Create a main-function where all will start "},{"id":8,"href":"/csX114/docs/Course/09_modules/","title":"09 Modules","section":"Docs","content":" Modules # Introduction # A module is a Python file containing definitions and statements that can be reused in other Python programs. Why?\nOrganize code. Promote code reuse. If you don\u0026rsquo;t you allow bugs to multiply and you\u0026rsquo;ll have to fix them wheever you copied the code. Use built-in functionalities provided by Python and the community. Saves a lot of effort Allows for RAD (Rapid Application Development) Create # Create a file called math_utils.py:\ndef add(a, b): return a + b def multiply(a, b): return a * b Use # Import and use modules from math_utils.py\nimport math_utils print(math_utils.add(3, 5)) print(math_utils.multiply(4, 6)) Different way:\nfrom math_utils import add print(add(2, 3)) Activity: create a simple module string_utils.py with functions like to_uppercase, to_lowercase, and use it in another script.\nBatteries Included: Python Standard Library # Python comes with a rich set of pre-installed modules for various tasks. Here the documentation.\nSome famous modules:\nmath import math print(math.sqrt(16)) print(math.pi) datetime from datetime import datetime now = datetime.now() print(f\u0026#34;Current time: {now}\u0026#34;) random import random print(random.randint(1, 100)) os Provides a way to interact with the operating system. Work with the FS (file system). Retrieve and set environment variables Run shell commands import os print(os.getcwd()) # Get current directory json import json data = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 25} json_string = json.dumps(data) print(json_string) Activity (7 min)\nUse math to calculate the square root of a number. Use random to generate a random number between 1 and 50. Use datetime to display the current date and time. Other mentions:\nshutil - High-level operations on files and directories. Used for copying, moving, and removing files or entire directories. copy - Provides functions to copy objects in Python. Supports both deep and shallow copies. time - Functions for working with time and delays. Provides utilities to measure execution time, format time, and create delays. sys - Provides access to system-specific parameters and functions. Often used to access CLI arguments. re - Provides support for regular expressions (regex) to work with text patterns. Used for powerful pattern matching, searching, and replacing strings. argparse - Used for creating user-friendly command-line interfaces. itertools - Provides a collection of fast and memory-efficient tools for working with iterators. Useful for looping, generating combinations, permutations, and more. decimal - the library if you need to work with decimal numbers without losing precision PyPI # The Python Package Index (PyPI) is a repository of software for the Python programming language.\nThis is how you install packages from there:\npip install requests And then you can start using them in your programs:\nimport requests response = requests.get(\u0026#34;https://api.github.com\u0026#34;) print(response.json()) Homework (graded) # Calculator # Create a module calculator.py with functions: add, subtract, multiply, and divide. Write a script that imports and uses this module.\nPyPI # Install the requests library. Use it to fetch the current weather for your city from a free API (e.g., OpenWeatherMap).\n"},{"id":9,"href":"/csX114/docs/Course/10_projects/","title":"10 Projects","section":"Docs","content":" Projects # A project is a temporary endeavor undertaken to create a unique product, service, or result. Key characteristics:\nClear objectives Defined scope Collaboration Time-bound Most of the work in IT is done in the context of projects. Examples of successful projects:\nOpen-source contributions (e.g., Linux, Python). Game development (e.g., Minecraft started as a side project). GIT # Version control system for tracking changes in source code. Collaboration tool for developers working on the same project. Core Concepts of Git:\nRepository (Repo): A folder Git tracks. Commit: A snapshot of changes. Branch: A parallel version of your project. Merge: Combining branches. Git is a distributed system therefore there is a server hosting the repository. From there you clone it to your computer and work in it. Changes are pushed to the remote repo.\nTo start a git repo first create an account on github, where your remote repo will be hosted. Add an ssh key so you can authenticate seamlessly for working with git. Then create a repo and clone it:\ngit clone git@github.com:uzak/csX114.git git status git add \u0026lt;file\u0026gt; git commit -m \u0026#34;Initial commit\u0026#34; git branch \u0026lt;branch-name\u0026gt; git checkout \u0026lt;branch-name\u0026gt; git checkout main git merge \u0026lt;branch-name\u0026gt; git push -u origin main Q\u0026amp;A # Team Project # * 2 - 3 members * Ideas: * hangman * tic-tac-toe "},{"id":10,"href":"/csX114/docs/Course/11_fp/","title":"11 Fuctional Programming","section":"Docs","content":" Functional Programming # Filter # Filters elements of a sequence based on a function that returns True or False.\n# Example: Filtering even numbers from a list numbers = [1, 2, 3, 4, 5, 6] even_numbers = list(filter(lambda x: x % 2 == 0, numbers)) print(even_numbers) # Output: [2, 4, 6] The list around filter is there so we don\u0026rsquo;t have to deal with generators, which is one of the more advanced topics in Python.\nMap # Applies a function to every item in a sequence.\n# Example: Squaring each number in a list numbers = [1, 2, 3, 4] squared_numbers = list(map(lambda x: x**2, numbers)) print(squared_numbers) # Output: [1, 4, 9, 16] Reduce # Reduces a sequence to a single value using a function.\nfrom functools import reduce # Example: Finding the product of a list of numbers numbers = [1, 2, 3, 4] product = reduce(lambda x, y: x * y, numbers) print(product) # Output: 24 List Comprehension # A compact way to generate or transform lists. Example: Creating a list of squares:\nnumbers = [1, 2, 3, 4] squared_numbers = [x**2 for x in numbers] print(squared_numbers) # Output: [1, 4, 9, 16] Example: Filtering even numbers:\neven_numbers = [x for x in numbers if x % 2 == 0] print(even_numbers) # Output: [2, 4] List comprehension can be used to generate sets and dictionaries.\nLambda Function # Anonymous, single-expression functions. Handy if you know the function will be short and will not be reused.\n# Example: Lambda function to add two numbers add = lambda x, y: x + y print(add(5, 3)) # Output: 8 # Example: Using lambda with map numbers = [1, 2, 3, 4] cubed_numbers = list(map(lambda x: x**3, numbers)) print(cubed_numbers) # Output: [1, 8, 27, 64] Homework (not graded) # Get an account w. codewars, if you don\u0026rsquo;t have already. Practice the following katas:\nhttps://www.codewars.com/kata/5697fb83f41965761f000052/solutions/python (use filter) https://www.codewars.com/kata/5390bac347d09b7da40006f6 (use map) https://www.codewars.com/kata/5715eaedb436cf5606000381 (use reduce) https://www.codewars.com/kata/546f922b54af40e1e90001da (use list comprehension) "},{"id":11,"href":"/csX114/docs/Course/12_oop/","title":"12 Object Oriented Programming","section":"Docs","content":" Object Oriented Programming # OOP is a programming paradigm based on the concept of objects. An object is a self-contained entity that contains data (attributes) and functions (methods) that operate on that data. OOP organizes code into reusable and logical structures called classes, which serve as blueprints for creating objects.\nWhy is OOP Used?\nCode Reusability: Through inheritance, OOP allows sharing and reusing common code, reducing duplication. Modularity: By encapsulating data and methods within classes, OOP promotes better organization and separation of concerns. Scalability and Maintainability: OOP makes code easier to update and scale as projects grow, thanks to its modular nature. Real-World Modeling: OOP reflects real-world entities and interactions, making it intuitive for developers to design systems. Flexibility with Polymorphism: Different objects can be used interchangeably if they share the same interface, enhancing flexibility in functionality. Why is OOP Popular?\nWidely Supported: OOP is supported by many modern programming languages like Python, Java, and C++. Intuitive Design: Concepts like objects, inheritance, and encapsulation closely mirror real-world concepts, making it easier for developers to think about problems and their solutions. Improved Collaboration: Teams can work on different classes and modules independently, streamlining development in large projects. Proven Effectiveness: OOP has been used in countless successful applications, from operating systems to web applications, proving its effectiveness in solving complex problems. Class # A class is a blueprint for creating objects. It defines the structure and behavior of objects, encapsulating data (attributes) and functionality (methods).\n# Define a class class Dog: def __init__(self, name, breed): self.name = name # Attribute self.breed = breed # Attribute def bark(self): # Method return f\u0026#34;{self.name} says Woof!\u0026#34; Object (Instance) # An object is an instance of a class. It is created using the class blueprint and has its own unique state (data).\n# Create instances (objects) of the class dog1 = Dog(\u0026#34;Buddy\u0026#34;, \u0026#34;Golden Retriever\u0026#34;) dog2 = Dog(\u0026#34;Max\u0026#34;, \u0026#34;Labrador\u0026#34;) print(dog1.name) # Output: Buddy print(dog2.breed) # Output: Labrador print(dog1.bark()) # Output: Buddy says Woof! Polymorphism # Polymorphism allows objects of different classes to be treated uniformly through shared methods. The method behaves differently based on the class of the object.\nclass Bird: def sound(self): return \u0026#34;Chirp\u0026#34; class Dog: def sound(self): return \u0026#34;Bark\u0026#34; def animal_sound(animal): print(animal.sound()) bird = Bird() dog = Dog() animal_sound(bird) # Output: Chirp animal_sound(dog) # Output: Bark Inheritance # Inheritance allows a class (child) to inherit attributes and methods from another class (parent), enabling code reuse and extending functionality.\nclass Animal: def eat(self): return \u0026#34;This animal is eating.\u0026#34; class Cat(Animal): # Cat inherits from Animal def meow(self): return \u0026#34;Meow!\u0026#34; cat = Cat() print(cat.eat()) # Output: This animal is eating. print(cat.meow()) # Output: Meow! Other OOP features # More advanced topics, that are not so strongly enforced by Python.\nEncapsulation # No direct access to object\u0026rsquo;s data is premitted. All operations happen through a well defined interface. In Python, introspection is at least as important thus Encapsulation is not taken as seriously as in Java/C++ etc. One underscore _ indicates that you\u0026rsquo;d only touch that variable/function if you know what you\u0026rsquo;re doing. Two underscored __ imply some name mangling thus making the introspection more difficult, yet not impossible. Example:\nclass Example: def __init__(self): self.public_var = \u0026#34;I am public\u0026#34; self._protected_var = \u0026#34;I am protected (use with caution)\u0026#34; self.__private_var = \u0026#34;I am private (name mangled)\u0026#34; def get_private_var(self): # Public interface to access private data return self.__private_var def set_private_var(self, value): # Public interface to modify private data self.__private_var = value # Create an instance of Example example = Example() # Access public variable print(example.public_var) # Output: I am public # Access protected variable (allowed, but not recommended) print(example._protected_var) # Output: I am protected (use with caution) # Attempt to access private variable directly (will fail) try: print(example.__private_var) except AttributeError as e: print(f\u0026#34;AttributeError: {e}\u0026#34;) # Output: AttributeError: \u0026#39;Example\u0026#39; object has no attribute \u0026#39;__private_var\u0026#39; # Access private variable using the public interface print(example.get_private_var()) # Output: I am private (name mangled) # Modify private variable using the public interface example.set_private_var(\u0026#34;New private value\u0026#34;) print(example.get_private_var()) # Output: New private value # Access private variable using name mangling (not recommended) print(example._Example__private_var) # Output: New private value Data Abstraction # Parent provides (part of) the implementation that relies on child\u0026rsquo;s details. Parent provides all the common data and functionality, children just provide the details the parent cannot know. Example:\nclass Animal: def eat(self): return f\u0026#34;{self.name()} is eating.\u0026#34; def name(self): return \u0026#34;Random Animal\u0026#34; class Cat(Animal): def meow(self): return \u0026#34;Meow!\u0026#34; def name(self): return \u0026#34;Cat\u0026#34; cat = Cat() print(cat.eat()) # Output: Cat is eating. print(cat.meow()) # Output: Meow! 7. Class vs. Instance Attributes and Methods # Class Attributes: Shared by all objects of the class. Instance Attributes: Unique to each object. Class Methods: Operate on class attributes and don\u0026rsquo;t require an instance. Instance Methods: Operate on instance attributes. class Car: wheels = 4 # Class attribute (shared by all instances) def __init__(self, make, model): self.make = make # Instance attribute self.model = model # Instance attribute @classmethod def change_wheels(cls, new_wheel_count): cls.wheels = new_wheel_count car1 = Car(\u0026#34;Toyota\u0026#34;, \u0026#34;Corolla\u0026#34;) car2 = Car(\u0026#34;Honda\u0026#34;, \u0026#34;Civic\u0026#34;) print(car1.wheels) # Output: 4 (class attribute) Car.change_wheels(6) print(car1.wheels) # Output: 6 (class attribute updated for all instances) "},{"id":12,"href":"/csX114/docs/Course/13_road_map/","title":"13 Recap \u0026 Road Map","section":"Docs","content":" Road Map # Python is great for prototyping. Maybe it won\u0026rsquo;t make for the most efficient application, but you\u0026rsquo;ll be able to create it in no time (RAD). That said, Python is very good to test out concepts.\nTo improving your core programming skills (in Python):\npractice: codewars and the like learn advanced Python: OOP, decorators, generators, context managers clean code Some of the useful modules you\u0026rsquo;d better know about:\nvenv decimal json itertools pytest sphinx (for documentation) re sys os shutil argparse General Use Cases # Presently, Python is predominantly being used in the following areas:\nWeb Apps # Web Frameworks django, flask, fastAPI jinja2 Data Science and AI # Data Science and Analytics pandas numpy matplotlib jupyter notebooks Ariticial Intelligence AI and Machine Learning ML tensorfow pytoch keras Other modules:\nrequests BeautifulSoap pyspark Automation # Automation and Scripting Cybersecurity Cloud Computing and DevOps Internet of Things Q/A # "},{"id":13,"href":"/csX114/docs/Course/14_presentation/","title":"14 Project Presentation","section":"Docs","content":"This class will be used for your project presentation. Make it an elevator pitch supported by slides and showcasing your project. SELL IT!\nEach team has 5 min. All team members should speak.\nAfter the presentation all the other students give feedback. Students split equally into six groups and give feedback on the following points:\nClarity Was the project idea clear and easy to understand? Did the team explain the purpose and problem their project solves? Engagement and Creativity Was the presentation engaging and visually appealing? Did the team use creative ways to capture attention? (e.g., storytelling, visuals, or examples) Structure and Flow Was the presentation well-structured, with a clear introduction, body, and conclusion? Did the content flow logically and smoothly? Team Collaboration Did all team members participate equally? Was the collaboration and coordination among team members evident? Relevance to the Audience Did the team highlight how the project would benefit or appeal to the intended audience? Was the problem and solution presented in a relatable manner? Persuasiveness Did the team effectively \u0026ldquo;sell\u0026rdquo; the project and convey its value? Did they include a call to action or strong closing statement? "},{"id":14,"href":"/csX114/docs/Course/codewars/","title":"Codewars","section":"Docs","content":"Get an account on codewars.com and start training. Practice makes a master, for as they say:\nIn theory there is no difference between theory and practice. In practice, there is. \u0026ndash; Yogi Berra\nGetting your feet wet # Requires all classes up to and including no. 6 (Structures).\n8: Convert a String to a Number! - don\u0026rsquo;t use int() 8: Jenny\u0026rsquo;s secret message 8: Returning Strings 8: Even or Odd 8: Remove First and Last Character 8: String repeat 8: Sentence Smash 8: Are you playing Banjo 8: A Needle in the Haystack 8: Multiply 8: Stringy Strings 8: Is it a number 8: Grasshoper - Grade Book 8: Remove spaces 8: Abbreviate a Two Word Name 8: Is the string uppercase? 8: Formatting Decimal Places #0 8: Formatting Decimal Places #1 8: Dollars and Cents Basics # 8: Count the Monkeys! 8: Reverse List Order 8: Basic Math Operations 8: Rock Paper Scissors! 8: If you can\u0026rsquo;t sleep, just count sheep!! 7: Find Count of Most Frequent Item in an Array 8: Surface Area and Volume of a Box 8: Convert number to reversed array of digits 7: Form The Minimum - easy 8: Sum of positive - use functools.reduce for extra coolnes 8: Parse nice int from char problem 7: Return substring instance count 7: Number ladder 8: Total amount of points 7: Reversed String - don\u0026rsquo;t use reversed function 7: Wovel count - if 7: Nth power rules them all 7: Disemwovel Trolls 7: Find the stray number - dict/if 7: Mumbling 7: Shortest Word 7: Jaden Casing Strings Intermediate # 7: Find Your Villain Name 7: Scrolling Text 7: Summing a number\u0026rsquo;s digits 7: My Language Skills 7: Find the Capitals 7: Aparently-Modifying strings 7: Add Length 7: Ones and Zeros 7: Number Pairs 7: Santa\u0026rsquo;s Naughty List 7: Sort array by string length 7: Sort by Last Char - not so easy 7: Nth Smallest Element 7: Remove Anchor from URL 7: Max diff 7: The Coupon Code 7: Sort Deck of Cards 7: Strong password? 7: Sorted Union 7: Operations with Sequence 5: First non-repeating character 6: Detect Pangram 7: Get Nth Even Number 7: Sorted? yes? no? how? 7: Sort Santa\u0026rsquo;s Reinder 7: Maximum Gap Advanced # 6: Who likes it? 6: Duplicate Encoder 6: Create Phone Number 6: Sum of Digits / Digital Root 6: Multiples of 3 or 5 6: Autocomplete! Yay! 6: Inside Out Strings 6: Find the Parity Outlier 6: Find the odd int 6: Counting Duplicates 6: Valid Braces 6: Stop gninnipS My sdroW! 6: Roman Numerals Encoder 6: Bit Counting 5: Simple Pig Latin 6: Title Case 5: Car Escape 4: Strip Comments 4: Human readable duration format 6: Count Repeats 6: Longest Palindrome 7: Reversing the bits in an integer FP # 8: Sum Arrays - use functools.reduce 7: List Filtering - use map 7: No oddities here - use filter 7: Curring functions: multiply all elements in array - use lambda OOP # 8: Color Ghost - ghost.color() is to be implemented 7: Building Spheres 8: Name Your Python 8: Basic subclasses - Adam and Eve Links # https://www.codewars.com/collections/basic-python. https://www.codewars.com/collections/python-basic-to-intermediate (7th level) https://www.codewars.com/collections/intermediate-training https://www.codewars.com/collections/training-intermediate https://www.codewars.com/collections/python-oop https://www.codewars.com/collections/functional-programming-practice "},{"id":15,"href":"/csX114/docs/Course/resources/","title":"Resources","section":"Docs","content":" Resources # Vimtutor. Web version of vimtutor that comes with VIM\nOpenVIM - learn VIM interactively\nPython Tutorial\nPython String Formatting Documentation\nCodewars - practice makes perfect\nAttendance and Grading Spring 2025 "}]