[{"id":0,"href":"/csX114/docs/Course/01_computers_and_programming/","title":"01 Introduction into Computers and Programming","section":"Docs","content":" Introduction to Computers and Programming # What is a Computer? # Electronic device that proccess data by following a set of instructions (= program). It can perform calculations, store and retrieve information and controlls devices.\nVon Neumann Architecture # Proposed by John von Neumann in 1945.\nInput devices # Serve to enter data and instructions. Analogy: like your senses - they gather information for the computer from the outside worlds. Examples:\nKeyboard Mouse Microphone Scanner Touch display Output devices # Present results of computer’s processing to the user. Examples:\nMonitor Printers Speakers Analogy: your actions. You communicate with (towards) the world by them.\nHow does a CPU work? # Control Unit (CU): The Brain of the computer. Control Unit directs flow between memory, CPU, I/O devices Arithmetic Logic Unit (ALU): performs arithmetic (+, -, …) and logical operations (AND, OR). Logical operations are also called boolean operations after George Boole. True is often represented as 1 and False as 0.\nLogical AND # Input A Input B A ∧ B 0 0 0 0 1 0 1 0 0 1 1 1 Logical OR # Input A Input B A ∨ B 0 0 0 0 1 1 1 0 1 1 1 1 Memory and Storage # Registers # Registers are small, high-speed storage locations within the CPU itself. Extremely fast (much faster than memory or storage). Very limited in size (typically 8, 16, 32, or 64 bits wide, depending on the CPU architecture). Registers fetch instructions from memory, store intermediate computation results, and provide operands for the CPU. RAM # Memory is the part of the system used for temporarily storing data and instructions that the CPU needs during program execution. It acts as the workspace for active processes and provides data to the CPU. Stores instructions fetched from storage so that they can be quickly accessed. Slower than registers but faster than storage. Larger in size compared to registers (e.g., modern systems have several GBs of RAM). Volatile: contents are lost when power is turned off. The CPU reads instructions and data from memory into registers. Once a task is complete, results may be written back to memory. Storage # Storage refers to non-volatile devices, such as hard drives (HDDs), solid-state drives (SSDs), or even cloud storage (e.g. AWS S3). Long-term retention of data and programs, even when the computer is turned off. Much slower than both memory and registers. Much larger capacity compared to memory and registers (e.g., modern systems often have TBs of storage). Operating Systems # An Operating System (OS) is software that manages a computer’s hardware and software resources, acting as an intermediary between users and the computer hardware. It ensures efficient execution of programs, resource allocation, and system stability.\nFunctions # Process Management Memory Management File System Management Device Management User Interface Types # Windows UNIX Linux Android macOS iOS Programming Languages # Programming languages are the medium for humans to write programs that a computer can execute. They are needed to:\nBridge the gap: Computers understand only binary (0 and 1). Computer languages allow for writing instructions in a human readable form. Simplification : allow to break down problems into Resuse: programs can be reused and automate repetitive tasks. Types # Low-Level Languages # Machine Language: Example: 10110000 01100001 Assembly langauage: symbolic representation of machine language using mnemonics. Example: MOV A, 5 ADD B, A High-Level Languages # Designed to be easier to read and write, closer to human languages. Requires a compiler or interpreter (or both) to translate into machine code. Examples:\nC: very low-level and thus performant. Compiled. Non-portable. Java: First compiled. Then resulting code is interpreted in the Java Virtual Machine. Cross-platform. Popular for enterprise apps. JavaScript: Very high level. Leans closer to C-style syntax. Used in browsers to create Frontends. Python: Very high level, easy to read, beginner friendly. Cross-platform. Popular for data-science (AI), prototyping and scripting. High level scripting languages are used for automating tasks. Examples:\nPython Bash Compiled vs. Interpreted # Computer only understands machine code Some languages compile their files into machine code (e.g. C) Some take the source code and interpret it (e.g. Python) Some use both approaches (e.g. Java) Usually low-level (performant) languages are compiled and high-level (closer to human thinking) are interprete.\nCommon Characteristics # Syntax: rules, how code must be written. Semantics: Meaning of a statement or instruction. Example: print(\u0026#34;Hello\u0026#34;) 2+2 Control Structures: loops and condititionals that control the flow of exeuction. Example if, while. Categories of High-Level Languages # Procedural: focus on a sequence of steps to solve a problem. Example: C. Object-Oriented: model entities of outside worlds as objects encapsulating data and behavior. Example: Java, C++. Functional: focus on mathematical functions. Example: Haskell. Logical: express facts and rules for reasoning. Example: Prolog. Some programming languages fit into several categories, e.g. Python and Javascript support both procedural, object-oriented and functional programming.\nHomework (graded) # Install htop. Don’t know how? Use Google/ChatGPT. Make a screenshot. Identify any process and explain what its values mean. "},{"id":1,"href":"/csX114/docs/Course/02_python_and_data/","title":"02 Python and Data","section":"Docs","content":" Python # Recap # Interactive Mode Scripts - files with .py extension Syntax and structure Syntax: rules, how code must be written. Semantics: Meaning of a statement or instruction. print() input() Variables # A variable is a name that stores a value, acting as a reference to that value in memory. It allows you to reuse and manipulate data in your programs. Example:\nx = 10 # Integer y = \u0026#34;Hello\u0026#34; # String z = 3.14 # Float x = \u0026#34;Now I\u0026#39;m a string!\u0026#34; # Reassignment Rules for Variable Names:\nMust start with a letter or an underscore (_). Cannot start with a number. Can contain letters, numbers, and underscores. Cannot use Python keywords (e.g., if, else, class). Snake Case # Snake case is a naming convention where words are written in lowercase and separated by underscores (_). It is commonly used in Python for variable and function names to improve readability. E.g. valid_name.\nComments # # this is the first comment spam = 1 # and this is the second comment # ... and now a third! text = \u0026#34;# This is not a comment because it\u0026#39;s inside quotes.\u0026#34; Statements and Expressions # Statement is a command. It does something, but not necessarily return a value. Expression is a combination of values, variables, operators, funtion calls that evaluates to a value. # Print statement print(\u0026#34;Hello, World!\u0026#34;) # Control structure (if statement) if x \u0026gt; 5: print(\u0026#34;x is greater than 5\u0026#34;) # Arithmetic expression 5 + 3 # Evaluates to 8 # Logical expression x \u0026gt; 5 # Evaluates to True or False # Function call as an expression len(\u0026#34;Python\u0026#34;) # Evaluates to 6 # String concatenation as an expression \u0026#34;Hello\u0026#34; + \u0026#34; World\u0026#34; # Evaluates to \u0026#34;Hello World\u0026#34; You can execute several statements (expressions) in one line. Don\u0026rsquo;t do that! Stick to one idea/task/expression per line. That way it will be easier to understand.\nData # Data refers to information or values that a computer program processes, stores, or manipulates. It can be as simple as a single number or as complex as a collection of multimedia files. In programming, data is categorized into data types, which define the kind of value and what operations can be performed on it.\nKinds of data types:\nPrimitive: Basic, indivisible data types like integers, floats, and booleans. Structured: Organized collections of data, like arrays, lists, and objects. Hand in hand with data types go operators. An operator is a symbol or keyword in programming that performs an action or operation on data (called operands). For example, + is an operator that adds two numbers.\nNumeric # Integer: int Float: float Complex: complex \u0026gt;\u0026gt;\u0026gt; # Let\u0026#39;s start with integers and floats \u0026gt;\u0026gt;\u0026gt; x = 42 # An integer \u0026gt;\u0026gt;\u0026gt; y = 3.14 # A float \u0026gt;\u0026gt;\u0026gt; # Check their types \u0026gt;\u0026gt;\u0026gt; type(x) \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; type(y) \u0026lt;class \u0026#39;float\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; # Perform basic arithmetic operations \u0026gt;\u0026gt;\u0026gt; x + y 45.14 \u0026gt;\u0026gt;\u0026gt; x - y 38.86 \u0026gt;\u0026gt;\u0026gt; x * y 131.88 \u0026gt;\u0026gt;\u0026gt; x / y # Division (always returns float) 13.375796178343949 \u0026gt;\u0026gt;\u0026gt; # Floor division and modulus \u0026gt;\u0026gt;\u0026gt; x // 5 # Integer division 8 \u0026gt;\u0026gt;\u0026gt; x % 5 # Remainder 2 \u0026gt;\u0026gt;\u0026gt; # Exponentiation \u0026gt;\u0026gt;\u0026gt; 2 ** 3 # 2 raised to the power of 3 8 \u0026gt;\u0026gt;\u0026gt; # Working with floats \u0026gt;\u0026gt;\u0026gt; z = 7.5 / 2 \u0026gt;\u0026gt;\u0026gt; z 3.75 \u0026gt;\u0026gt;\u0026gt; # Rounding floats \u0026gt;\u0026gt;\u0026gt; round(z, 1) # Round to 1 decimal place 3.8 \u0026gt;\u0026gt;\u0026gt; # Type conversions (casting) \u0026gt;\u0026gt;\u0026gt; int(z) # Convert float to integer (truncates) 3 \u0026gt;\u0026gt;\u0026gt; float(x) # Convert integer to float 42.0 \u0026gt;\u0026gt;\u0026gt; # Handling very large numbers \u0026gt;\u0026gt;\u0026gt; big_number = 12345678901234567890 \u0026gt;\u0026gt;\u0026gt; big_number * 2 24691357802469135780 \u0026gt;\u0026gt;\u0026gt; # Scientific notation for small numbers \u0026gt;\u0026gt;\u0026gt; small_number = 1e-10 # Equivalent to 0.0000000001 \u0026gt;\u0026gt;\u0026gt; small_number 1e-10 \u0026gt;\u0026gt;\u0026gt; # Some built-in functions \u0026gt;\u0026gt;\u0026gt; abs(-42) # Absolute value 42 \u0026gt;\u0026gt;\u0026gt; pow(2, 3) # 2 raised to the power of 3 (same as 2 ** 3) 8 Text # String: str Existing strings cannot be changed. You can only use them to create new strings out of the existing ones. \u0026gt;\u0026gt;\u0026gt; # Let\u0026#39;s start with basic strings \u0026gt;\u0026gt;\u0026gt; name = \u0026#34;Alice\u0026#34; \u0026gt;\u0026gt;\u0026gt; greeting = \u0026#34;Hello\u0026#34; \u0026gt;\u0026gt;\u0026gt; # Check the type of a string \u0026gt;\u0026gt;\u0026gt; type(name) \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; # Concatenate strings \u0026gt;\u0026gt;\u0026gt; full_greeting = greeting + \u0026#34;, \u0026#34; + name + \u0026#34;!\u0026#34; \u0026gt;\u0026gt;\u0026gt; full_greeting \u0026#39;Hello, Alice!\u0026#39; \u0026gt;\u0026gt;\u0026gt; # Repeating strings \u0026gt;\u0026gt;\u0026gt; excited_greeting = full_greeting * 2 \u0026gt;\u0026gt;\u0026gt; excited_greeting \u0026#39;Hello, Alice!Hello, Alice!\u0026#39; \u0026gt;\u0026gt;\u0026gt; # Accessing characters by index \u0026gt;\u0026gt;\u0026gt; full_greeting[0] # First character \u0026#39;H\u0026#39; \u0026gt;\u0026gt;\u0026gt; full_greeting[-1] # Last character \u0026#39;!\u0026#39; \u0026gt;\u0026gt;\u0026gt; # Slicing strings \u0026gt;\u0026gt;\u0026gt; full_greeting[0:5] # First 5 characters \u0026#39;Hello\u0026#39; \u0026gt;\u0026gt;\u0026gt; full_greeting[7:] # Everything from index 7 onwards \u0026#39;Alice!\u0026#39; \u0026gt;\u0026gt;\u0026gt; full_greeting[:5] # Everything up to index 5 (exclusive) \u0026#39;Hello\u0026#39; \u0026gt;\u0026gt;\u0026gt; # String length \u0026gt;\u0026gt;\u0026gt; len(full_greeting) 13 \u0026gt;\u0026gt;\u0026gt; # Converting case \u0026gt;\u0026gt;\u0026gt; full_greeting.upper() # Uppercase \u0026#39;HELLO, ALICE!\u0026#39; \u0026gt;\u0026gt;\u0026gt; full_greeting.lower() # Lowercase \u0026#39;hello, alice!\u0026#39; \u0026gt;\u0026gt;\u0026gt; # Stripping whitespace \u0026gt;\u0026gt;\u0026gt; padded = \u0026#34; hello, world! \u0026#34; \u0026gt;\u0026gt;\u0026gt; padded.strip() \u0026#39;hello, world!\u0026#39; \u0026gt;\u0026gt;\u0026gt; padded.lstrip() \u0026#39;hello, world! \u0026#39; \u0026gt;\u0026gt;\u0026gt; padded.rstrip() \u0026#39; hello, world!\u0026#39; \u0026gt;\u0026gt;\u0026gt; # Splitting strings \u0026gt;\u0026gt;\u0026gt; sentence = \u0026#34;Python is awesome\u0026#34; \u0026gt;\u0026gt;\u0026gt; words = sentence.split() # Split into a list of words (we\u0026#39;ll deal with lists later) \u0026gt;\u0026gt;\u0026gt; words [\u0026#39;Python\u0026#39;, \u0026#39;is\u0026#39;, \u0026#39;awesome\u0026#39;] \u0026gt;\u0026gt;\u0026gt; # Joining strings \u0026gt;\u0026gt;\u0026gt; \u0026#34;-\u0026#34;.join(words) # Combine words with a hyphen \u0026#39;Python-is-awesome\u0026#39; \u0026gt;\u0026gt;\u0026gt; # Checking substrings \u0026gt;\u0026gt;\u0026gt; \u0026#34;awesome\u0026#34; in sentence # Is \u0026#34;awesome\u0026#34; part of the sentence? True \u0026gt;\u0026gt;\u0026gt; \u0026#34;boring\u0026#34; in sentence False \u0026gt;\u0026gt;\u0026gt; # Replacing parts of a string \u0026gt;\u0026gt;\u0026gt; sentence.replace(\u0026#34;awesome\u0026#34;, \u0026#34;fantastic\u0026#34;) \u0026#39;Python is fantastic\u0026#39; \u0026gt;\u0026gt;\u0026gt; # Formatting strings - string interpolatoin \u0026gt;\u0026gt;\u0026gt; age = 25 \u0026gt;\u0026gt;\u0026gt; formatted = f\u0026#34;My name is {name} and I am {age} years old.\u0026#34; \u0026gt;\u0026gt;\u0026gt; formatted \u0026#39;My name is Alice and I am 25 years old.\u0026#39; \u0026gt;\u0026gt;\u0026gt; # Advanced formatting (see: https://pyformat.info/) \u0026gt;\u0026gt;\u0026gt; pi = 3.14159 \u0026gt;\u0026gt;\u0026gt; f\u0026#34;The value of pi is approximately {pi:.2f}\u0026#34; # Format to 2 decimal places \u0026#39;The value of pi is approximately 3.14\u0026#39; Strings are texts in quotes (\u0026quot;) or apostrophes (') on one line. Multiline strings begin and end with triple quotes or apostrophes. E.g.: \u0026gt;\u0026gt;\u0026gt; long_text = \u0026#34;\u0026#34;\u0026#34;Line 1 ... Line 2 ... ... ... and here is the END\u0026#34;\u0026#34;\u0026#34; \u0026gt;\u0026gt;\u0026gt; long_text \u0026#39;Line 1\\nLine 2\\n...\\nand here is the END\u0026#39; \u0026gt;\u0026gt;\u0026gt; \\n is new line character. All characters starting with \\ are called escape sequences and contain special characters. input() always returns a string, even if the user enter digits. It\u0026rsquo;s your job to convert it to number. Example:\n\u0026gt;\u0026gt;\u0026gt; number = input(\u0026#34;Please enter a number: \u0026#34;) Please enter a number: 42 \u0026gt;\u0026gt;\u0026gt; number \u0026#39;42\u0026#39; \u0026gt;\u0026gt;\u0026gt; type(number) \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; number = int(number) \u0026gt;\u0026gt;\u0026gt; type(number) \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; number 42 Boolean # Boolean: bool Valid values are True and False. Comparisons yield these values. \u0026gt;\u0026gt;\u0026gt; # Booleans represent True or False \u0026gt;\u0026gt;\u0026gt; t = True \u0026gt;\u0026gt;\u0026gt; f = False \u0026gt;\u0026gt;\u0026gt; # Check the type of a boolean \u0026gt;\u0026gt;\u0026gt; type(t) \u0026lt;class \u0026#39;bool\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; # Boolean operations \u0026gt;\u0026gt;\u0026gt; t and f # Logical AND False \u0026gt;\u0026gt;\u0026gt; t or f # Logical OR True \u0026gt;\u0026gt;\u0026gt; not t # Logical NOT False \u0026gt;\u0026gt;\u0026gt; # Booleans with comparison operators \u0026gt;\u0026gt;\u0026gt; 5 \u0026gt; 3 # Greater than True \u0026gt;\u0026gt;\u0026gt; 5 \u0026lt; 3 # Less than False \u0026gt;\u0026gt;\u0026gt; 5 == 5 # Equal to True \u0026gt;\u0026gt;\u0026gt; 5 != 3 # Not equal to True \u0026gt;\u0026gt;\u0026gt; # Combining comparisons \u0026gt;\u0026gt;\u0026gt; 5 \u0026gt; 3 and 2 \u0026lt; 4 True \u0026gt;\u0026gt;\u0026gt; 5 \u0026gt; 3 or 2 \u0026gt; 4 True \u0026gt;\u0026gt;\u0026gt; not (5 \u0026gt; 3) False \u0026gt;\u0026gt;\u0026gt; # Booleans with arithmetic operations \u0026gt;\u0026gt;\u0026gt; True + 1 # True is treated as 1 2 \u0026gt;\u0026gt;\u0026gt; False + 1 # False is treated as 0 1 \u0026gt;\u0026gt;\u0026gt; # Boolean casting \u0026gt;\u0026gt;\u0026gt; bool(1) # Non-zero numbers are True True \u0026gt;\u0026gt;\u0026gt; bool(0) # Zero is False False \u0026gt;\u0026gt;\u0026gt; bool(\u0026#34;Hello\u0026#34;) # Non-empty strings are True True \u0026gt;\u0026gt;\u0026gt; bool(\u0026#34;\u0026#34;) # Empty strings are False False \u0026gt;\u0026gt;\u0026gt; bool([]) # Empty lists are False False \u0026gt;\u0026gt;\u0026gt; bool([1, 2, 3]) # Non-empty lists are True True \u0026gt;\u0026gt;\u0026gt; age = 19 \u0026gt;\u0026gt;\u0026gt; is_adult = age \u0026gt;= 18 # expression + assignment \u0026gt;\u0026gt;\u0026gt; is_adult True None # None is a special constant in Python that represents the absence of a value or a null value.\n\u0026gt;\u0026gt;\u0026gt; x = None \u0026gt;\u0026gt;\u0026gt; x is None True \u0026gt;\u0026gt;\u0026gt; x is not None False \u0026gt;\u0026gt;\u0026gt; Homework (graded) # Calculator # Create a program that will read three numbers, store them in three distinct variables and then create the sum of them. This will be stored in another variable. Then it will print the variable result saying: \u0026ldquo;result is N\u0026rdquo; where N is the sum.\nMeter # Create a program that will let the user input his name. The program will then say how many characters are there in his name.\nExtra points: if spaces are inserted, substract their count from the result, so that \u0026ldquo;Peter Pan\u0026rdquo; will return 8 and not 9.\n"},{"id":2,"href":"/csX114/docs/Course/03_control_structures_and_loops/","title":"03 Control Strutures and Loops","section":"Docs","content":" Conditionals # Conditionals in a programming language are used to make decisions in the flow of a program based on whether certain conditions are met. They allow the program to execute different code paths depending on the evaluation of a condition (True or False).\nif Statement # The if statement allows executing a block of code if a condition is True.\nx = 10 if x \u0026gt; 5: print(\u0026#34;x is greater than 5\u0026#34;) # Output: x is greater than 5 Nested Conditions # x = 10 if x \u0026gt; 5: if x \u0026lt; 15: print(\u0026#34;x is between 5 and 15\u0026#34;) # Output: x is between 5 and 15 Logical Operations in Conditions # Combine conditions using and, or, and not.\nx = 10 if x \u0026gt; 5 and x \u0026lt; 15: print(\u0026#34;x is between 5 and 15\u0026#34;) # Output: x is between 5 and 15 if-else Statement # Adds an alternative block when the condition is False.\nx = 3 if x \u0026gt; 5: print(\u0026#34;x is greater than 5\u0026#34;) else: print(\u0026#34;x is not greater than 5\u0026#34;) # Output: x is not greater than 5 if-elif-else Statement # x = 7 if x \u0026gt; 10: print(\u0026#34;x is greater than 10\u0026#34;) elif x \u0026gt; 5: print(\u0026#34;x is greater than 5 but not more than 10\u0026#34;) # Output else: print(\u0026#34;x is 5 or less\u0026#34;) There can be any number of elif sections.\nLoops # Loops execute a block of code repeatedly, saving time and effort. They\u0026rsquo;re used for:\nRepetition: Automate repetitive tasks. Example: Printing numbers 1 to 10. Iteration: Process items in a sequence (e.g., list or string). Example: Summing numbers in a list. Conditional Repetition. Example: Prompt user until input is valid. while loop # Repeats as long as the condition is True.\nx = 1 while x \u0026lt;= 5: print(x) # Output: 1 2 3 4 5 x += 1 break and continue # break exits the loop. continue skips to the next iteration. x = 0 while x \u0026lt; 5: x += 1 if x == 3: continue if x == 5: break print(x) # Output: 1 2 4 Both keywords work in both while and for loops.\nfor loop # Iterates over a sequence.\nfor i in [1, 2, 3]: print(i) # Output: 1 2 3 range() function # Generates a sequence of numbers.\nfor i in range(1, 6): print(i) # Output: 1 2 3 4 5 nested loops # Loops inside loops for multi-dimensional iteration.\nfor i in range(1, 3): for j in range(1, 3): print(f\u0026#34;i={i}, j={j}\u0026#34;) infinite loops # while True: print(\u0026#34;Infinite Loop\u0026#34;) pass # A placeholder that does nothing but satisfies syntax requirements.\nfor i in range(3): pass # Placeholder for future code Homework (graded) # conditionals # Create a calculator that will ask the user for operand1, operation (+/-/*/division), operand2 and will read the values, convert them to numbers and print the result\nloops # Create a Number Guessing Game in Python. Write a Python program that allows a user to guess a secret number between 1 and 10. The program should guide the user by providing feedback on whether their guess is too low, too high, or correct. The game continues until the user guesses the correct number.\n"},{"id":3,"href":"/csX114/docs/Course/04_algorithm/","title":"04 Algorithms","section":"Docs","content":" What Is an Algorithm? # An algorithm is a step-by-step set of instructions designed to perform a specific task or solve a particular problem. It is the foundation of all computer programs and is used to process data, make decisions, or automate repetitive tasks.\nDaily Life Examples of Algorithm # Making a Cup of Tea:\nStep 1: Fill the kettle with water. Step 2: Boil the water. Step 3: Place a tea bag in a cup. Step 4: Pour boiling water into the cup. Step 5: Add sugar/milk if desired. Step 6: Stir and serve. Finding a Word in a Dictionary:\nStep 1: Open the dictionary. Step 2: Locate the section based on the first letter of the word. Step 3: Narrow down based on the second and subsequent letters. Step 4: Find the word and read its definition. Crossing the Street:\nStep 1: Look left. Step 2: Look right. Step 3: Look left again. Step 4: If the road is clear, cross; otherwise, wait. Key Features of an Algorithm: # Input: The algorithm accepts zero or more inputs to work with. Output: The algorithm produces one (or multiple) result or outcome. Definiteness: Each step must be clearly defined without ambiguity. Finiteness: The algorithm must terminate after a finite number of steps. Effectiveness: Each step of the algorithm can be performed in a finite amount of time using available resources. KISS (Keep It Simple Stupid)\nWhat Is Pseudocode? # Pseudocode is a simplified, informal way of writing algorithms that uses plain language and basic programming constructs without worrying about syntax. It bridges the gap between human thinking and actual code. Example of Pseudocode:\nTask: Find the largest number in a list. Input: list of numbers 1. Initialize a variable Max to the first element of the list. 2. For each element in the list: a. If the element is greater than Max: i. Set Max to this element. 3. Output: Max. Advantages of Using Pseudocode # Language-Independent: It\u0026rsquo;s not tied to a specific programming language. Focus on Logic: Allows the designer to focus on the algorithm\u0026rsquo;s structure without worrying about syntax. Easy to Understand: Non-programmers can follow and provide feedback. MSI # Manually. Always solve the problem manually first (ideally on paper). Step-by-Step. Then design the algorithm. What are the steps that need to be taken? Impelement. Proceed to implement the algorithm in a programming language. Homework (graded) # Given a string. Return two numbers (tuple), the first will represent the number of spaces in the string, the other of non-spaces. Your task is pass the M. and S. steps on paper and only then to implement the algorithm in Python. Both the paper and the script are required.\n"},{"id":4,"href":"/csX114/docs/Course/05_functions/","title":"05 Functions","section":"Docs","content":" Funtions in Python # Introduction # Functions are reusable blocks of code that perform a specific task. They implement na algorithm. Moreover, they help us organize and structure our programs, avoid repetition, and improve readability.\nFunction reduce complexity, as the user (caller) of a function doesn\u0026rsquo;t need to know the algorithm, only what\u0026rsquo;s the input and expected output. Thus, from the perspective of the caller of the function it is a blackbox.\nA function in Python is defined using the def keyword:\n# Defining function def greet(): print(\u0026#34;Hello, World!\u0026#34;) # Calling the function greet() A function like greet that doesn\u0026rsquo;t contain a return statement automatically returns the value None. As such it is also called a procedure. A proper function returns a value. Example:\ndef calculate_circumference(radius): if radius \u0026lt; 0: raise ValueError(\u0026#34;Radius cannot be negative\u0026#34;) pi = 3.141592653589793 return 2 * pi * radius radius = 5 circumference = calculate_circumference(radius) print(f\u0026#34;The circumference of a circle with radius {radius} is {circumference}\u0026#34;) When a return statement is executed, the function terminates at that point returning the value to the caller and gives control to the caller.\nArguments # Functions can accept inputs called arguments. These allow the function to work with dynamic data.\nPositional Arguments # Positional arguments are the most common type. Their order is important:\ndef greet_person(name): # `name` is a positional argument print(f\u0026#34;Hello, {name}!\u0026#34;) greet_person(\u0026#34;Alice\u0026#34;) The values passed to a function in the place of an argument are called parameters. So in the example above the parameter for greet_person is \u0026quot;Alice\u0026quot;.\nDefault Arguments # Default arguments have predefined values. If not provided during the call, the default is used:\ndef greet_person(name=\u0026#34;Stranger\u0026#34;): print(f\u0026#34;Hello, {name}!\u0026#34;) # Calling the function greet_person() # Uses default value greet_person(\u0026#34;Bob\u0026#34;) # Overrides default value Arbitrary Argument List # Sometimes, you may not know how many arguments will be passed to the function. You can use *args to accept a variable number of arguments:\ndef greet_people(*names): for name in names: print(f\u0026#34;Hello, {name}!\u0026#34;) greet_people(\u0026#34;Alice\u0026#34;, \u0026#34;Bob\u0026#34;, \u0026#34;Charlie\u0026#34;) Arbitrary Keyword Arguments # def describe_person(**details): for key, value in details.items(): print(f\u0026#34;{key}: {value}\u0026#34;) # Calling the function describe_person(name=\u0026#34;Alice\u0026#34;, age=25, location=\u0026#34;New York\u0026#34;) Docstrings # A docstring is a special string that describes what the function does. It is written as the first statement inside the function body and is usually enclosed in triple quotes (\u0026quot;\u0026quot;\u0026quot; or \u0026lsquo;\u0026rsquo;\u0026rsquo;).\n# Example: Function with Docstring def greet_person(name): \u0026#34;\u0026#34;\u0026#34; Greets a person with the provided name. Args: name (str): The name of the person to greet. Returns: None \u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;Hello, {name}!\u0026#34;) print(greet_person.__doc__) # Accessing a function\u0026#39;s docstring greet_person(\u0026#39;Peter\u0026#39;) # Calling is as usual Homework (graded) # Basic Function # Write a function say_hello that prints \u0026ldquo;Hello, Python!\u0026rdquo;. Call the function to ensure it works.\nPositional and Default Arguments # Write a function introduce that takes two arguments: name and age (default value for age should be 18). Print a sentence introducing the person. Call the function with both arguments and with only name.\nArbitrary Arguments # Write a function list_hobbies that accepts any number of hobby names using *args. Print all hobbies passed to the function. Call the function with at least three hobby names.\nKeyword Arguments # Write a function person_details that accepts name, age, and city as keyword arguments. Print these details in a formatted string. Call the function using keyword arguments in different orders.\nArbitrary Keyword Arguments # Write a function profile that accepts any number of keyword arguments using **kwargs. Print all the key-value pairs in a readable format. Call the function with at least three key-value pairs.\nDocstring # Write a function calculate_area that calculates and returns the area of a rectangle given length and width. Add a docstring explaining the purpose of the function, its arguments, and what it returns. Access and print the docstring. Call the function to test it.\nCombo # Combine all these concepts into a single function full_profile that takes:\nA mandatory positional argument for name. A default argument for age. An arbitrary list of hobbies using *args. Additional details using **kwargs. Print the complete profile in a structured format.\n"},{"id":5,"href":"/csX114/docs/Course/06_structures/","title":"06 Structures","section":"Docs","content":" Structures # Structures in programming are ways to organize, store, and manage data efficiently. They determine how data is arranged in memory and how operations like accessing, adding, or modifying data can be performed.\nStructures in Python are called collections and create complex data types out of primitive ones or other structures.\nTuple # Immutable, ordered collections of items.\nCannot be changed after creation. Just like strings. Use parentheses () to define. # Example: Storing coordinates point = (3, 5) print(\u0026#34;X:\u0026#34;, point[0], \u0026#34;Y:\u0026#34;, point[1]) # Tuple unpacking x, y = point print(f\u0026#34;Point coordinates: X={x}, Y={y}\u0026#34;) The parentheses can be omitted. Python will know based on the coma that it deals with a tuple:\npoint = 3, 5 print(\u0026#34;X:\u0026#34;, point[0], \u0026#34;Y:\u0026#34;, point[1]) Lists # Mutable, ordered collections of items.\nCan grow or shrink dynamically. Use square brackets [] to define. # Example: Managing a to-do list tasks = [\u0026#34;Read book\u0026#34;, \u0026#34;Write code\u0026#34;, \u0026#34;Go jogging\u0026#34;] tasks.append(\u0026#34;Cook dinner\u0026#34;) # Add an item tasks.remove(\u0026#34;Write code\u0026#34;) # Remove an item print(tasks) # Access by index print(\u0026#34;First task:\u0026#34;, tasks[0]) Sets # Unordered collections of unique items.\nDoesn\u0026rsquo;t allow for duplicates. Use curly braces {} to define or set() constructor. # Example: Removing duplicates from a list numbers = [1, 2, 3, 1, 2, 4] unique_numbers = set(numbers) print(\u0026#34;Unique numbers:\u0026#34;, unique_numbers) # Set operations set_a = {1, 2, 3} set_b = {3, 4, 5} print(\u0026#34;Union:\u0026#34;, set_a | set_b) # Combine both sets print(\u0026#34;Intersection:\u0026#34;, set_a \u0026amp; set_b) # Common elements Dictionaries # Mutable, unordered collections of key-value pairs.\nKeys are unique and immutable. Use curly braces {} with key-value pairs to define. # Example: Storing user information user = { \u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 25, \u0026#34;location\u0026#34;: \u0026#34;New York\u0026#34; } print(user[\u0026#34;name\u0026#34;]) # Access value by key # Adding or modifying key-value pairs user[\u0026#34;age\u0026#34;] = 26 user[\u0026#34;email\u0026#34;] = \u0026#34;alice@example.com\u0026#34; print(user) # Iterating over keys and values for key, value in user.items(): print(f\u0026#34;{key}: {value}\u0026#34;) Summary # Structure Mutable Ordered Unique Items Common Use Tuple No Yes No Fixed data List Yes Yes No Dynamic data Set Yes No Yes Unique items Dict Yes No Keys are unique Key-value pairs Homework (graded) # Books # Create a list of your favorite books. Remove duplicates using a set.\nCities # Store details about a city (name, population, country) in a dictionary and update the population.\nDistance in 3D space # Use a tuple to represent a point in a 3D space and calculate its distance from the origin.\n"},{"id":6,"href":"/csX114/docs/Course/07_io/","title":"07 Input/Output","section":"Docs","content":" Input/Output # Communication with the user and the environment.\nString Interpolation # String interpolation is inserting variables or expressions into strings. Python offers several ways to achieve this:\nf-strings (from Python 3.6): f\u0026quot;Hello, {name}\u0026quot;. str.format(): \u0026ldquo;Hello, {}\u0026quot;.format(name). % strings: \u0026ldquo;Hello, %s\u0026rdquo; % name We focus here only on the first method. Examples:\nname = \u0026#34;Alice\u0026#34; age = 25 # Using f-strings greeting = f\u0026#34;Hello, {name}! You are {age} years old.\u0026#34; print(greeting) # Evaluating expressions in f-strings calculation = f\u0026#34;2 + 2 = {2 + 2}\u0026#34; print(calculation) String Formatting # Formatting strings allows control over how data appears. Use placeholders for alignment, padding, or precision:\n{}: Default placeholder. {:.2f}: Floating-point with 2 decimal places. {:\u0026lt;10}: Left-align in 10-character width. Example:\n# Numeric formatting price = 19.99 formatted_price = f\u0026#34;Price: ${price:.2f}\u0026#34; # Two decimal places print(formatted_price) # Alignment data = \u0026#34;Python\u0026#34; print(f\u0026#34;\u0026#39;{data:\u0026lt;10}\u0026#39;\u0026#34;) # Left-align print(f\u0026#34;\u0026#39;{data:\u0026gt;10}\u0026#39;\u0026#34;) # Right-align print(f\u0026#34;\u0026#39;{data:^10}\u0026#39;\u0026#34;) # Center-align Console # You can interact with the user via the console (in text based UIs):\n# Printing output print(\u0026#34;Welcome to the console class!\u0026#34;) # Getting user input name = input(\u0026#34;Enter your name: \u0026#34;) print(f\u0026#34;Hello, {name}!\u0026#34;) Advanced stuff:\n# Print without a newline print(\u0026#34;Loading\u0026#34;, end=\u0026#34;\u0026#34;) for _ in range(3): print(\u0026#34;.\u0026#34;, end=\u0026#34;\u0026#34;) print(\u0026#34; Done!\u0026#34;) # Formatting console output value = 42 print(f\u0026#34;The answer is: {value:010}\u0026#34;) # Padded with zeroes Files # Files allow reading and writing persistent data (on storage). Python uses the open() function with modes:\n'r': Read. 'w': Write (overwrites existing content). 'a': Append. Boy scout rule - always leave the place in the same or better state as you encountered it. Thus always close the files after you finished working with them. If you use the with keyword to work with them, Python will do that for you automatically, even if an exception occurs while working with it.\nExamples:\n# Writing to a file with open(\u0026#34;example.txt\u0026#34;, \u0026#34;w\u0026#34;) as file: file.write(\u0026#34;Hello, file!\u0026#34;) # Reading from a file with open(\u0026#34;example.txt\u0026#34;, \u0026#34;r\u0026#34;) as file: content = file.read() print(\u0026#34;File content:\u0026#34;, content) # Appending to a file with open(\u0026#34;example.txt\u0026#34;, \u0026#34;a\u0026#34;) as file: file.write(\u0026#34;\\nThis is appended text.\u0026#34;) # Reading line by line with open(\u0026#34;example.txt\u0026#34;, \u0026#34;r\u0026#34;) as file: for line in file: print(line.strip()) Command Line Arguments (sys.argv) # The sys.argv list allows you to access command-line arguments passed to a Python script.\nsys.argv[0] is the name of the script, and subsequent elements are the arguments.\nExample:\nimport sys # Example: Accessing command-line arguments if len(sys.argv) \u0026gt; 1: print(\u0026#34;Arguments passed:\u0026#34;, sys.argv[1:]) else: print(\u0026#34;No arguments passed.\u0026#34;) # Example: Simple command-line calculator if len(sys.argv) == 4: num1 = float(sys.argv[1]) operator = sys.argv[2] num2 = float(sys.argv[3]) if operator == \u0026#39;+\u0026#39;: print(f\u0026#34;Result: {num1 + num2}\u0026#34;) elif operator == \u0026#39;-\u0026#39;: print(f\u0026#34;Result: {num1 - num2}\u0026#34;) elif operator == \u0026#39;*\u0026#39;: print(f\u0026#34;Result: {num1 * num2}\u0026#34;) elif operator == \u0026#39;/\u0026#39;: print(f\u0026#34;Result: {num1 / num2}\u0026#34;) else: print(\u0026#34;Unsupported operator!\u0026#34;) else: print(\u0026#34;Usage: python script.py \u0026lt;num1\u0026gt; \u0026lt;operator\u0026gt; \u0026lt;num2\u0026gt;\u0026#34;) Homework (graded) # 1 # Create a formatted report with the names and scores of students using string formatting.\n2 # Write a script to: * Ask the user for their name and age. * Save this data to a file. * Read and display the content of the file.\n"},{"id":7,"href":"/csX114/docs/Course/08_errors_and_exceptions/","title":"08 Errors and Exceptions","section":"Docs","content":" Errors Exceptions Debugging Clean Code few rules "},{"id":8,"href":"/csX114/docs/Course/09_modules/","title":"09 Modules","section":"Docs","content":" import Bateries Included: stdlib pypi "},{"id":9,"href":"/csX114/docs/Course/10_projects/","title":"10 Projects","section":"Docs","content":" Projects # Projects Git Basics Team Project 2 - 3 members "},{"id":10,"href":"/csX114/docs/Course/11_fp/","title":"11 Fuctional Programming","section":"Docs","content":" Functional Programming # filter reduce map list comprehension lambda functions generators "},{"id":11,"href":"/csX114/docs/Course/12_oop/","title":"12 Object Oriented Programming","section":"Docs","content":" Object Oriented Programming # "},{"id":12,"href":"/csX114/docs/Course/13_road_map/","title":"13 Road Map","section":"Docs","content":" Road Map # venv argparse flask, django jinja2 requests re os / shutil decimal json itertools "},{"id":13,"href":"/csX114/docs/Course/14_presentation/","title":"14 Project Presentation","section":"Docs","content":"TBD\n"},{"id":14,"href":"/csX114/docs/Course/resources/","title":"Resources","section":"Docs","content":" Resources # Vimtutor. Web version of vimtutor that comes with VIM\nOpenVIM - learn VIM interactively\nPython Tutorial\nPython String Formatting Documentation\nCodewars - practice makes perfect\n"}]